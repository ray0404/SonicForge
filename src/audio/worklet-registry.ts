// Auto-generated by scripts/bundle-worklets.js
export const workletSources: Record<string, string> = {
  "autowah-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass AutoWahProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'baseFrequency', defaultValue: 100, minValue: 20, maxValue: 5000 },\n            { name: 'sensitivity', defaultValue: 0.5, minValue: 0, maxValue: 10 }, // Gain to Freq\n            { name: 'octaves', defaultValue: 4, minValue: 0, maxValue: 8 }, // Range\n            { name: 'Q', defaultValue: 2.0, minValue: 0.1, maxValue: 20 },\n            { name: 'attack', defaultValue: 0.01, minValue: 0.001, maxValue: 1 },\n            { name: 'release', defaultValue: 0.1, minValue: 0.001, maxValue: 1 },\n            { name: 'wet', defaultValue: 1.0, minValue: 0, maxValue: 1 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.followers = [];\n        this.filters = [];\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        const baseFreqP = parameters.baseFrequency;\n        const sensP = parameters.sensitivity;\n        const octP = parameters.octaves;\n        const QP = parameters.Q;\n        const attP = parameters.attack;\n        const relP = parameters.release;\n        const wetP = parameters.wet;\n\n        if (this.followers.length < input.length) {\n            for (let i = this.followers.length; i < input.length; i++) {\n                this.followers.push(new EnvelopeFollower());\n                this.filters.push(new BiquadFilter());\n            }\n        }\n\n        for (let ch = 0; ch < input.length; ch++) {\n            const follower = this.followers[ch];\n            const filter = this.filters[ch];\n\n            // Const checking optimized out for brevity, reading index 0 or i\n            // AudioWorklet usually passes arrays.\n\n            // Update Follower Params (K-rate)\n            const att = attP.length === 1 ? attP[0] : attP[0]; // K-rate for ease\n            const rel = relP.length === 1 ? relP[0] : relP[0];\n            follower.setParams(att, rel, sampleRate);\n\n            const baseFreq = baseFreqP.length === 1 ? baseFreqP[0] : baseFreqP[0];\n            const sens = sensP.length === 1 ? sensP[0] : sensP[0];\n            const octaves = octP.length === 1 ? octP[0] : octP[0];\n            const Q = QP.length === 1 ? QP[0] : QP[0];\n            const wet = wetP.length === 1 ? wetP[0] : wetP[0];\n\n            for (let i = 0; i < input[ch].length; i++) {\n                const x = input[ch][i];\n                \n                // 1. Envelope\n                const env = follower.process(x);\n\n                // 2. Modulation\n                // Logic: cutoff = base * 2^(env * sens * octaves)\n                const mod = env * sens * octaves;\n                const cutoff = baseFreq * Math.pow(2, mod);\n                const safeCutoff = Math.min(cutoff, sampleRate / 2.1);\n\n                // 3. Filter\n                // Update filter coefficients per sample for smooth wah\n                // (Optimized: Could do Control Rate (every 128 samples) with interpolation \n                // but for \"Professional Grade\", sample rate modulation is smoother)\n                filter.setParams(safeCutoff, 0, Q, sampleRate, 'bandpass'); // Or 'peaking'? Doc says Bandpass or Peaking. Wah is usually BP or LP. AutoWah usually BP.\n                \n                const wetSig = filter.process(x);\n                \n                // Mix\n                output[ch][i] = x * (1 - wet) + wetSig * wet;\n            }\n        }\n        return true;\n    }\n}\n\nregisterProcessor('autowah-processor', AutoWahProcessor);\n",
  "bitcrusher-processor.js": "class BitCrusherProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'bits', defaultValue: 8, minValue: 1, maxValue: 16 },\n            { name: 'normFreq', defaultValue: 1.0, minValue: 0.001, maxValue: 1.0 }, // Target Sample Rate (0.0 to 1.0)\n            { name: 'mix', defaultValue: 1.0, minValue: 0.0, maxValue: 1.0 } // Optional but good standard\n        ];\n    }\n\n    constructor() {\n        super();\n        this.phasor = 0;\n        this.lastSample = 0;\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        const bitsParam = parameters.bits;\n        const freqParam = parameters.normFreq;\n        const mixParam = parameters.mix;\n\n        const isConstBits = bitsParam.length === 1;\n        const isConstFreq = freqParam.length === 1;\n        const isConstMix = mixParam.length === 1;\n\n        // Channel state needed for Stereo downsampling coherence? \n        // Usually bitcrusher effects are linked or dual mono. \n        // I'll assume linked for the \"phasor\" (downsample clock) or separate?\n        // Separate is safer for true stereo processing.\n        // For scaffold, I'll use `this.phasor` (shared) or reset?\n        // Let's use local variables if I process one channel, but AudioWorklet handles multi-channel.\n        // I should have per-channel state.\n        \n        // Quick fix: Just process channel 0 logic for phasor and apply to all? \n        // Or maintain array of phasors. \n        // I'll stick to a shared phasor for phase coherence between L/R (stereo image preservation).\n        \n        let phasor = this.phasor;\n        let holdSample = this.lastSample; // Shared hold sample? No, hold sample must be per channel.\n        // Okay, I need per-channel hold sample. \n        // But shared phasor (clock).\n        \n        // Wait, if I have stereo input, the \"hold\" value is different for L and R.\n        // So I need `holdSamples = [0, 0]`.\n        if (!this.holdSamples || this.holdSamples.length < input.length) {\n            this.holdSamples = new Float32Array(input.length);\n        }\n\n        for (let i = 0; i < input[0].length; i++) {\n            const normFreq = isConstFreq ? freqParam[0] : freqParam[i];\n            const bits = isConstBits ? bitsParam[0] : bitsParam[i];\n            const mix = isConstMix ? mixParam[0] : mixParam[i];\n\n            const step = Math.pow(2, bits);\n            \n            // Advance phasor\n            phasor += normFreq;\n            \n            const shouldUpdate = phasor >= 1.0;\n            if (shouldUpdate) {\n                phasor -= 1.0;\n            }\n\n            for (let ch = 0; ch < input.length; ch++) {\n                const inSample = input[ch][i];\n                \n                if (shouldUpdate) {\n                    // Quantize new sample\n                    // y = floor(x * steps) / steps\n                    this.holdSamples[ch] = Math.floor(inSample * step) / step;\n                }\n                \n                // Output held sample (Downsampled & Quantized)\n                const crushed = this.holdSamples[ch];\n                \n                // Mix\n                output[ch][i] = crushed * mix + inSample * (1 - mix);\n            }\n        }\n        \n        this.phasor = phasor;\n        \n        return true;\n    }\n}\n\nregisterProcessor('bitcrusher-processor', BitCrusherProcessor);\n",
  "chorus-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass ChorusProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'frequency', defaultValue: 1.5, minValue: 0.1, maxValue: 10.0 }, // LFO Rate\n            { name: 'delayTime', defaultValue: 0.03, minValue: 0.0, maxValue: 0.1 }, // Base Delay (s)\n            { name: 'depth', defaultValue: 0.002, minValue: 0.0, maxValue: 0.01 }, // Modulation Width (s)\n            { name: 'feedback', defaultValue: 0.0, minValue: 0.0, maxValue: 0.95 },\n            { name: 'wet', defaultValue: 0.5, minValue: 0.0, maxValue: 1.0 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.delays = [];\n        this.lfos = [];\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        const freqParam = parameters.frequency;\n        const delayParam = parameters.delayTime;\n        const depthParam = parameters.depth;\n        const fbParam = parameters.feedback;\n        const wetParam = parameters.wet;\n\n        // Init state\n        if (this.delays.length < input.length) {\n            for (let i = this.delays.length; i < input.length; i++) {\n                this.delays.push(new DelayLine(0.5, sampleRate)); // Max 0.5s\n                this.lfos.push(new LFO());\n                // Offset LFOs for stereo spread? \n                // Standard Chorus often flips phase or offsets L/R LFOs.\n                // I'll add PI/2 offset to Right channel for width.\n                if (i === 1) this.lfos[i].phase = Math.PI / 2;\n            }\n        }\n\n        for (let ch = 0; ch < input.length; ch++) {\n            const inputChannel = input[ch];\n            const outputChannel = output[ch];\n            const delayLine = this.delays[ch];\n            const lfo = this.lfos[ch];\n\n            const isConstFreq = freqParam.length === 1;\n\n            for (let i = 0; i < inputChannel.length; i++) {\n                const x = inputChannel[i];\n                \n                const freq = isConstFreq ? freqParam[0] : freqParam[i];\n                const baseDelay = delayParam.length === 1 ? delayParam[0] : delayParam[i];\n                const depth = depthParam.length === 1 ? depthParam[0] : depthParam[i];\n                const fb = fbParam.length === 1 ? fbParam[0] : fbParam[i];\n                const wet = wetParam.length === 1 ? wetParam[0] : wetParam[i];\n\n                // Calculate Modulated Delay Time\n                // LFO output is -1 to 1. \n                // ModDelay = Base + Depth * sin(wt)\n                const lfoOut = lfo.process(freq, sampleRate);\n                const modDelaySeconds = baseDelay + (depth * lfoOut);\n                \n                // Convert to samples\n                const modDelaySamples = modDelaySeconds * sampleRate;\n\n                // Read (interpolated)\n                const delayedSample = delayLine.read(modDelaySamples);\n                \n                // Feedback\n                const nextInput = x + (delayedSample * fb);\n                delayLine.write(nextInput);\n\n                // Mix\n                outputChannel[i] = x * (1 - wet) + delayedSample * wet;\n            }\n        }\n\n        return true;\n    }\n}\n\nregisterProcessor('chorus-processor', ChorusProcessor);\n",
  "compressor-processor.js": "class CompressorProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'threshold', defaultValue: -24, minValue: -60, maxValue: 0 },\n            { name: 'ratio', defaultValue: 4, minValue: 1, maxValue: 20 },\n            { name: 'attack', defaultValue: 0.01, minValue: 0.0001, maxValue: 1 }, // sec\n            { name: 'release', defaultValue: 0.1, minValue: 0.001, maxValue: 2 }, // sec\n            { name: 'knee', defaultValue: 5, minValue: 0, maxValue: 20 }, // dB or Factor for VarMu\n            { name: 'makeupGain', defaultValue: 0, minValue: 0, maxValue: 24 }, // dB\n            { name: 'mode', defaultValue: 0, minValue: 0, maxValue: 3 }, // 0=VCA, 1=FET, 2=Opto, 3=VarMu\n            { name: 'mix', defaultValue: 1.0, minValue: 0, maxValue: 1 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.channels = [];\n        this.lastPost = 0;\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        const threshP = parameters.threshold;\n        const ratioP = parameters.ratio;\n        const attP = parameters.attack;\n        const relP = parameters.release;\n        const kneeP = parameters.knee;\n        const gainP = parameters.makeupGain;\n        const modeP = parameters.mode;\n        const mixP = parameters.mix;\n\n        // Init State\n        if (this.channels.length < input.length) {\n            for (let i = this.channels.length; i < input.length; i++) {\n                this.channels.push({\n                    gr: 0, // Current Gain Reduction in dB\n                    lastOutput: 0 // For FET feedback\n                });\n            }\n        }\n\n        // Processing\n        // Simplified: Assuming stereo link usually desired for compressors to preserve image,\n        // but typically plugins implement dual mono or linked. \n        // I'll implement per-channel (Dual Mono) for simplicity of loop, \n        // but note that stereo linking is \"Professional\". \n        // Given the constraints, Dual Mono is safer to implement quickly.\n\n        let maxGR = 0;\n\n        for (let ch = 0; ch < input.length; ch++) {\n            const state = this.channels[ch];\n            const inCh = input[ch];\n            const outCh = output[ch];\n\n            const mode = modeP.length === 1 ? modeP[0] : modeP[0];\n            const thresh = threshP.length === 1 ? threshP[0] : threshP[0];\n            const ratioBase = ratioP.length === 1 ? ratioP[0] : ratioP[0];\n            const knee = kneeP.length === 1 ? kneeP[0] : kneeP[0]; // Used as Knee Factor for VarMu\n            const makeupDb = gainP.length === 1 ? gainP[0] : gainP[0];\n            const makeup = Math.pow(10, makeupDb / 20);\n\n            // Ballistics Coeffs\n            const att = attP.length === 1 ? attP[0] : attP[0];\n            const rel = relP.length === 1 ? relP[0] : relP[0];\n            const mix = mixP.length === 1 ? mixP[0] : mixP[0];\n            \n            // Standard exp decay coeffs\n            const attCoeff = Math.exp(-1.0 / (Math.max(0.0001, att) * sampleRate));\n            const baseRelCoeff = Math.exp(-1.0 / (Math.max(0.001, rel) * sampleRate));\n\n            for (let i = 0; i < inCh.length; i++) {\n                const x = inCh[i];\n\n                // 1. Detection Source\n                let detectorIn = x;\n                if (mode === 1) { // FET: Feedback\n                    detectorIn = state.lastOutput;\n                }\n\n                // 2. Level Detection (Peak)\n                const absIn = Math.abs(detectorIn);\n                const envDb = 20 * Math.log10(absIn + 1e-6);\n\n                // 3. Gain Calculation\n                let overshoot = envDb - thresh;\n                let targetGR = 0;\n\n                if (overshoot > 0) {\n                    let r = ratioBase;\n                    \n                    if (mode === 3) { // VarMu: Ratio increases with gain reduction/overshoot\n                        // Ratio = 1 + Overshoot * KneeFactor?\n                        // Doc: Ratio_effective = 1.0 + (Overshoot_dB * KneeFactor)\n                        // KneeFactor typically small (e.g. 0.1 to 0.5)\n                        r = 1.0 + (overshoot * (knee * 0.1)); // Scaling knee param 0-20 to 0-2 factor?\n                    }\n                    \n                    // Standard compression formula\n                    // GR = (Input - Thresh) * (1 - 1/R)\n                    targetGR = overshoot * (1 - 1 / Math.max(1, r));\n                }\n\n                // 4. Ballistics (Attack/Release)\n                let relCoeff = baseRelCoeff;\n\n                if (mode === 2) { // Opto: Program Dependent Release\n                    // alpha_r(t) = BaseRelease * (1 - Envelope(t)) ?\n                    relCoeff = baseRelCoeff * (1 - Math.min(1, absIn)); \n                }\n\n                // Apply Ballistics to GR State\n                if (targetGR > state.gr) {\n                    // Attack\n                    state.gr = attCoeff * state.gr + (1 - attCoeff) * targetGR;\n                } else {\n                    // Release\n                    state.gr = relCoeff * state.gr + (1 - relCoeff) * targetGR;\n                }\n\n                // Track Max GR for UI\n                if (state.gr > maxGR) maxGR = state.gr;\n\n                // 5. Apply\n                // Gain = -GR dB\n                const gain = Math.pow(10, -state.gr / 20);\n                \n                const processed = x * gain * makeup;\n                outCh[i] = x * (1 - mix) + processed * mix;\n                state.lastOutput = processed; // For FET\n            }\n        }\n\n        // Post Message every ~100ms (sampleRate * 0.1)\n        // currentTime is available in AudioWorkletGlobalScope\n        const now = currentTime;\n        if (now - this.lastPost > 0.1) {\n            this.port.postMessage({ type: 'reduction', value: maxGR });\n            this.lastPost = now;\n        }\n\n        return true;\n    }\n}\n\nregisterProcessor('compressor-processor', CompressorProcessor);\n",
  "deesser-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass DeEsserProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'frequency', defaultValue: 6000, minValue: 2000, maxValue: 10000 },\n            { name: 'threshold', defaultValue: -20, minValue: -60, maxValue: 0 },\n            { name: 'ratio', defaultValue: 4, minValue: 1, maxValue: 20 },\n            { name: 'attack', defaultValue: 0.005, minValue: 0.001, maxValue: 0.1 }, // Fast attack\n            { name: 'release', defaultValue: 0.05, minValue: 0.01, maxValue: 0.5 },\n            { name: 'monitor', defaultValue: 0, minValue: 0, maxValue: 1 }, // 0=Off, 1=Listen to Sidechain\n            { name: 'bypass', defaultValue: 0, minValue: 0, maxValue: 1 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.channelState = [];\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        // Ensure state exists for each channel\n        if (this.channelState.length < input.length) {\n            for (let i = this.channelState.length; i < input.length; i++) {\n                this.channelState.push({\n                    filter: new BiquadFilter(),\n                    envelope: new EnvelopeFollower(),\n                    gainReduction: 0\n                });\n            }\n        }\n\n        const frequency = parameters.frequency.length > 1 ? parameters.frequency[0] : parameters.frequency[0];\n        const threshold = parameters.threshold.length > 1 ? parameters.threshold[0] : parameters.threshold[0];\n        const ratio = parameters.ratio.length > 1 ? parameters.ratio[0] : parameters.ratio[0];\n        const attack = parameters.attack.length > 1 ? parameters.attack[0] : parameters.attack[0];\n        const release = parameters.release.length > 1 ? parameters.release[0] : parameters.release[0];\n        const monitor = parameters.monitor.length > 1 ? parameters.monitor[0] : parameters.monitor[0] > 0.5;\n        const bypass = parameters.bypass.length > 1 ? parameters.bypass[0] : parameters.bypass[0] > 0.5;\n\n        for (let ch = 0; ch < input.length; ch++) {\n            const inputChannel = input[ch];\n            const outputChannel = output[ch];\n            const state = this.channelState[ch];\n\n            // Update Filter Params (Bandpass for Sibilance)\n            // Q is fixed around 1.0 - 2.0 for De-essing usually\n            state.filter.setParams(frequency, 0, 2.0, sampleRate, 'bandpass');\n            state.envelope.setParams(attack, release, sampleRate);\n\n            for (let i = 0; i < inputChannel.length; i++) {\n                const sample = inputChannel[i];\n\n                if (bypass) {\n                    outputChannel[i] = sample;\n                    continue;\n                }\n\n                // 1. Filter Sidechain\n                const sidechain = state.filter.process(sample);\n\n                // 2. Envelope Detection\n                const env = state.envelope.process(sidechain);\n                const envDb = 20 * Math.log10(env + 1e-6);\n\n                // 3. Gain Reduction Logic\n                let reductionDb = 0;\n                if (envDb > threshold) {\n                    reductionDb = (envDb - threshold) * (1 - 1 / ratio);\n                }\n\n                // Smooth GR? (Envelope Follower handles ballistics on the *detection*, \n                // but standard compressors apply attack/release to the *gain reduction* signal.\n                // Our simple EnvelopeFollower here tracks the *signal level*. \n                // So if signal drops, env drops. \n                // This is a \"Feed-forward VCA\" topology.\n                // Using the envelope directly is fine for a basic de-esser.\n                \n                const gain = Math.pow(10, -reductionDb / 20);\n\n                if (monitor) {\n                    // Output the filtered sidechain so user can tune frequency\n                    outputChannel[i] = sidechain;\n                } else {\n                    // Apply gain reduction to original broadband signal\n                    outputChannel[i] = sample * gain;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n\nregisterProcessor('deesser-processor', DeEsserProcessor);\n",
  "distortion-processor.js": "class DistortionProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'drive', defaultValue: 1.0, minValue: 1.0, maxValue: 100.0 }, // Drive as multiplier\n            { name: 'wet', defaultValue: 1.0, minValue: 0.0, maxValue: 1.0 },\n            { name: 'type', defaultValue: 0, minValue: 0, maxValue: 2 }, // 0: Tanh, 1: Atan, 2: Cubic\n            { name: 'outputGain', defaultValue: 0.0, minValue: -24.0, maxValue: 24.0 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.lastSample = 0;\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        const driveParam = parameters.drive;\n        const wetParam = parameters.wet;\n        const typeParam = parameters.type;\n        const outGainParam = parameters.outputGain;\n\n        const isConstDrive = driveParam.length === 1;\n        const isConstWet = wetParam.length === 1;\n        const isConstType = typeParam.length === 1;\n        const isConstGain = outGainParam.length === 1;\n\n        // Optimization: Hoist Constant Calculations\n        const constDrive = isConstDrive ? driveParam[0] : 0;\n        const constWet = isConstWet ? wetParam[0] : 0;\n        // Pre-round type for constant case as shaper expects integer\n        const constTypeInt = isConstType ? Math.round(typeParam[0]) : 0;\n        const constOutGain = isConstGain ? Math.pow(10, outGainParam[0] / 20.0) : 0;\n\n        for (let channel = 0; channel < input.length; channel++) {\n            const inputChannel = input[channel];\n            const outputChannel = output[channel];\n            let lastX = this.lastSample; // Simple state for 2x oversampling interpolation\n\n            for (let i = 0; i < inputChannel.length; i++) {\n                const x = inputChannel[i];\n                \n                const drive = isConstDrive ? constDrive : driveParam[i];\n                const wet = isConstWet ? constWet : wetParam[i];\n                const type = isConstType ? constTypeInt : typeParam[i];\n                const outGain = isConstGain ? constOutGain : Math.pow(10, outGainParam[i] / 20.0);\n\n                // 2x Oversampling (Linear Interpolation + Averaging)\n                // 1. Interpolate intermediate sample\n                const x_interp = 0.5 * (x + lastX);\n                \n                // 2. Process both samples\n                const y_real = this.shaper(x * drive, type);\n                const y_interp = this.shaper(x_interp * drive, type);\n\n                // 3. Decimate (Average)\n                const processed = 0.5 * (y_real + y_interp);\n                \n                // Mix\n                outputChannel[i] = (processed * wet + x * (1 - wet)) * outGain;\n\n                lastX = x;\n            }\n            // Note: Per-channel state persistence between blocks is simplified here.\n            // In a production environment with critical fidelity requirements,\n            // explicit per-channel state management (this.channelState[ch]) would be preferred.\n        }\n        \n        return true;\n    }\n\n    shaper(x, type) {\n        const t = Math.round(type);\n        if (t === 0) {\n            // Soft Clipping (Tanh)\n            return Math.tanh(x);\n        } else if (t === 1) {\n            // ArcTangent (Harder Clip)\n            // f(x) = (2/PI) * atan(x)\n            return (2.0 / Math.PI) * Math.atan(x);\n        } else {\n            // Simple Soft Clip (Cubic)\n            // f(x) = x - x^3/3 if -1.5 < x < 1.5\n            if (x > -1.5 && x < 1.5) {\n                return x - (x * x * x) / 3.0;\n            } else {\n                return x > 0 ? 1.0 : -1.0;\n            }\n        }\n    }\n}\n\nregisterProcessor('distortion-processor', DistortionProcessor);",
  "dithering-processor.js": "class DitheringProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        { name: 'bitDepth', defaultValue: 24, minValue: 8, maxValue: 32 }\n      ];\n    }\n  \n    process(inputs, outputs, parameters) {\n      const input = inputs[0];\n      const output = outputs[0];\n      const bitDepthParam = parameters.bitDepth;\n  \n      if (!input || !input[0] || !output) return true;\n  \n      const channelCount = input.length;\n  \n      for (let channel = 0; channel < channelCount; channel++) {\n        const inputChannel = input[channel];\n        const outputChannel = output[channel];\n        const length = inputChannel.length;\n  \n        // Optimization: check if bitDepth is constant\n        const isDepthConst = bitDepthParam.length === 1;\n        let currentDepth = bitDepthParam[0];\n        \n        // Cache scale if constant\n        let scale = Math.pow(2, currentDepth - 1);\n        \n        for (let i = 0; i < length; i++) {\n          if (!isDepthConst) {\n              currentDepth = bitDepthParam[i];\n              scale = Math.pow(2, currentDepth - 1);\n          }\n  \n          // If depth is >= 32, we treat it as bypass (float 32 processing)\n          if (currentDepth >= 32) {\n              outputChannel[i] = inputChannel[i];\n              continue;\n          }\n  \n          const sample = inputChannel[i];\n  \n          // 1. Scale up\n          let val = sample * scale;\n  \n          // 2. Add TPDF noise (Triangular Probability Density Function)\n          // Sum of two uniform random variables (-0.5 to 0.5) * 2 effectively?\n          // dithering.ts used: Math.random() - Math.random()\n          // This generates a value between -1 and 1, with triangular distribution centered at 0.\n          // This represents +/- 1 LSB of dither.\n          const noise = Math.random() - Math.random();\n          val += noise;\n  \n          // 3. Round to nearest integer\n          val = Math.round(val);\n  \n          // 4. Scale down\n          val = val / scale;\n  \n          // 5. Hard clip\n          if (val > 1.0) val = 1.0;\n          else if (val < -1.0) val = -1.0;\n  \n          outputChannel[i] = val;\n        }\n      }\n  \n      return true;\n    }\n  }\n  \n  registerProcessor('dithering-processor', DitheringProcessor);\n",
  "dynamic-eq-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass DynamicEQProcessor extends AudioWorkletProcessor {\n  static get parameterDescriptors() {\n    return [\n      { name: 'frequency', defaultValue: 1000, minValue: 20, maxValue: 20000 },\n      { name: 'Q', defaultValue: 1.0, minValue: 0.1, maxValue: 100 },\n      { name: 'gain', defaultValue: 0, minValue: -40, maxValue: 40 }, \n      { name: 'threshold', defaultValue: -20, minValue: -100, maxValue: 0 },\n      { name: 'ratio', defaultValue: 1, minValue: 1, maxValue: 20 },\n      { name: 'attack', defaultValue: 0.01, minValue: 0.001, maxValue: 1 },\n      { name: 'release', defaultValue: 0.1, minValue: 0.001, maxValue: 1 }\n    ];\n  }\n\n  constructor() {\n    super();\n    this.channelState = [];\n    this.framesProcessed = 0;\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0];\n    if (!input || !output) return true;\n\n    // Parameter smoothing is handled by the host automation usually, \n    // but here we grab the array or single value.\n    // For simplicity, we grab index 0 (k-rate for most, unless automated)\n    // To support a-rate, we'd loop i.\n    const freq = parameters.frequency.length > 1 ? parameters.frequency : parameters.frequency[0];\n    const Q = parameters.Q.length > 1 ? parameters.Q : parameters.Q[0];\n    const staticGain = parameters.gain.length > 1 ? parameters.gain : parameters.gain[0];\n    const thresh = parameters.threshold.length > 1 ? parameters.threshold : parameters.threshold[0];\n    const ratio = parameters.ratio.length > 1 ? parameters.ratio : parameters.ratio[0];\n    const att = parameters.attack.length > 1 ? parameters.attack : parameters.attack[0];\n    const rel = parameters.release.length > 1 ? parameters.release : parameters.release[0];\n\n    // Determine if params are static (k-rate) or dynamic (a-rate)\n    const isFreqStatic = typeof freq === 'number';\n    const isQStatic = typeof Q === 'number';\n\n    // Initialize state for new channels\n    if (this.channelState.length < input.length) {\n      for (let i = this.channelState.length; i < input.length; i++) {\n        this.channelState.push({\n          scFilter: new BiquadFilter(),\n          mainFilter: new BiquadFilter(),\n          envFollower: new EnvelopeFollower()\n        });\n      }\n    }\n\n    let maxGainReduction = 0;\n\n    for (let channel = 0; channel < input.length; channel++) {\n      const inputData = input[channel];\n      const outputData = output[channel];\n      const state = this.channelState[channel];\n      \n      // Update envelope params (k-rate optimized)\n      state.envFollower.setParams(att, rel, sampleRate);\n\n      // Optimization: If Frequency and Q are static, update base math ONCE per block\n      if (isFreqStatic && isQStatic) {\n          state.scFilter.updateBase(freq, Q, sampleRate, 'bandpass');\n          state.scFilter.setGain(0); // SC doesn't need gain\n          \n          state.mainFilter.updateBase(freq, Q, sampleRate, 'peaking');\n      }\n\n      for (let i = 0; i < inputData.length; i++) {\n        const sample = inputData[i];\n        \n        // 1. Sidechain Path\n        // If parameters are a-rate, we must update base every sample\n        if (!isFreqStatic || !isQStatic) {\n            state.scFilter.updateBase(\n                isFreqStatic ? freq : freq[i],\n                isQStatic ? Q : Q[i],\n                sampleRate,\n                'bandpass'\n            );\n            state.scFilter.setGain(0);\n        }\n\n        const scSample = state.scFilter.process(sample);\n        \n        // Detect Envelope\n        const envLevel = state.envFollower.process(scSample);\n        const envDb = 20 * Math.log10(envLevel + 1e-6); // Convert to dB\n        \n        // Calculate Gain Reduction\n        // If env > threshold, reduce gain\n        let gainReduction = 0;\n        if (envDb > thresh) {\n             gainReduction = (envDb - thresh) * (1 - 1/ratio);\n        }\n        \n        // Track max GR for UI visualization\n        if (gainReduction > maxGainReduction) maxGainReduction = gainReduction;\n        \n        // 2. Main Path\n        // Modulate gain: TargetGain = StaticGain - GainReduction\n        const dynamicGain = staticGain - gainReduction;\n        \n        // Update main filter\n        // If parameters are a-rate, we need to update base. \n        // If k-rate, it was done outside loop.\n        if (!isFreqStatic || !isQStatic) {\n            state.mainFilter.updateBase(\n                isFreqStatic ? freq : freq[i],\n                isQStatic ? Q : Q[i],\n                sampleRate, \n                'peaking'\n            );\n        }\n        \n        // ALWAYS update gain (this is the \"Dynamic\" part)\n        state.mainFilter.setGain(dynamicGain);\n        \n        outputData[i] = state.mainFilter.process(sample);\n      }\n    }\n\n    // Debug / Visualization Message\n    this.framesProcessed++;\n    if (this.framesProcessed >= 60) {\n      this.port.postMessage({ type: 'debug', gainReduction: maxGainReduction });\n      this.framesProcessed = 0;\n    }\n\n    return true;\n  }\n}\n\nregisterProcessor('dynamic-eq-processor', DynamicEQProcessor);\n",
  "feedback-delay-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass FeedbackDelayProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'delayTime', defaultValue: 0.5, minValue: 0.0, maxValue: 2.0 }, // Max 2s\n            { name: 'feedback', defaultValue: 0.3, minValue: 0.0, maxValue: 0.95 },\n            { name: 'wet', defaultValue: 0.5, minValue: 0.0, maxValue: 1.0 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.delays = [];\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        const delayTimeP = parameters.delayTime;\n        const fbP = parameters.feedback;\n        const wetP = parameters.wet;\n\n        if (this.delays.length < input.length) {\n            for (let i = this.delays.length; i < input.length; i++) {\n                this.delays.push(new DelayLine(2.0, sampleRate));\n            }\n        }\n\n        for (let ch = 0; ch < input.length; ch++) {\n            const delayLine = this.delays[ch];\n\n            for (let i = 0; i < input[ch].length; i++) {\n                const x = input[ch][i];\n                const dt = delayTimeP.length === 1 ? delayTimeP[0] : delayTimeP[i];\n                const fb = fbP.length === 1 ? fbP[0] : fbP[i];\n                const wet = wetP.length === 1 ? wetP[0] : wetP[i];\n\n                // Read Output first\n                // delayTime in seconds -> samples\n                const delaySamples = dt * sampleRate;\n                const wetSig = delayLine.read(delaySamples); // Use interpolated read for smooth changes\n\n                // Feedback Path\n                // Write = Input + Delayed * Feedback\n                const toBuffer = x + wetSig * fb;\n                delayLine.write(toBuffer);\n\n                // Mix\n                output[ch][i] = x * (1 - wet) + wetSig * wet;\n            }\n        }\n        return true;\n    }\n}\n\nregisterProcessor('feedback-delay-processor', FeedbackDelayProcessor);\n",
  "limiter-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass LimiterProcessor extends AudioWorkletProcessor {\n  static get parameterDescriptors() {\n    return [\n      { name: 'threshold', defaultValue: -0.5, minValue: -60, maxValue: 0 },\n      { name: 'ceiling', defaultValue: -0.1, minValue: -20, maxValue: 0 },\n      { name: 'release', defaultValue: 0.1, minValue: 0.001, maxValue: 1 },\n      { name: 'lookahead', defaultValue: 5, minValue: 0, maxValue: 20 } // ms\n    ];\n  }\n\n  constructor() {\n    super();\n    this.channelState = [];\n    this.framesProcessed = 0;\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0];\n    if (!input || !output) return true;\n\n    // Get parameters\n    const thresholdDb = parameters.threshold.length > 1 ? parameters.threshold[0] : parameters.threshold[0];\n    const ceilingDb = parameters.ceiling.length > 1 ? parameters.ceiling[0] : parameters.ceiling[0];\n    const releaseTime = parameters.release.length > 1 ? parameters.release[0] : parameters.release[0];\n    const lookaheadMs = parameters.lookahead.length > 1 ? parameters.lookahead[0] : parameters.lookahead[0];\n\n    // Initialize state\n    if (this.channelState.length < input.length) {\n      for (let i = this.channelState.length; i < input.length; i++) {\n        this.channelState.push({\n          delay: new DelayLine(0.050, sampleRate), // Max 50ms buffer\n          env: new EnvelopeFollower()\n        });\n      }\n    }\n\n    const thresholdLinear = Math.pow(10, thresholdDb / 20);\n    const ceilingLinear = Math.pow(10, ceilingDb / 20);\n    \n    // Lookahead in samples\n    const lookaheadSamples = Math.floor((lookaheadMs / 1000) * sampleRate);\n    \n    // Attack is usually very fast for limiters\n    const attackTime = 0.001; \n\n    let maxGainReduction = 0;\n\n    for (let channel = 0; channel < input.length; channel++) {\n      const inputData = input[channel];\n      const outputData = output[channel];\n      const state = this.channelState[channel];\n      \n      // Update envelope params\n      state.env.setParams(attackTime, releaseTime, sampleRate);\n\n      for (let i = 0; i < inputData.length; i++) {\n        const sample = inputData[i];\n\n        // 1. Write current sample to delay line (for audio path)\n        state.delay.write(sample);\n\n        // 2. Sidechain Analysis (Lookahead path)\n        // We analyze the *current* sample (which is \"future\" compared to the delayed output)\n        // Check amplitude\n        const absInput = Math.abs(sample);\n        \n        // 3. Envelope Follower (Detect Peak)\n        // We want to detect if the *future* signal exceeds threshold\n        // But we actually want the gain reduction to apply *when that signal arrives* at output.\n        // Standard Lookahead Limiter:\n        //  - Delay Audio by N\n        //  - Analyze Input (Lookahead)\n        //  - If Input > Threshold, ramp down gain.\n        //  - Because we are analyzing \"N\" samples early, the gain reduction envelope has time to attack *before* the peak hits the output.\n        //  - This implies we might need to delay the *envelope* control signal relative to the audio?\n        //  - Actually, simpler:\n        //    Input -> Delay -> Output\n        //    Input -> Envelope -> GR Calculation -> Multiply Output\n        \n        const envLevel = state.env.process(sample);\n        \n        // Calculate required gain to stay under threshold\n        let targetGain = 1.0;\n        if (envLevel > thresholdLinear) {\n            targetGain = thresholdLinear / envLevel;\n        }\n        \n        // We can apply Ceiling here too:\n        // Final Output = Sample * Gain * (Ceiling / Threshold) ?\n        // Usually: Limiter clamps to Threshold, then Post-Gain boosts/cuts to Ceiling.\n        // If Threshold = -10dB, Ceiling = -1dB. We limit to -10, then add +9dB makeup.\n        // Here, let's keep it simple: \"Limit to Threshold\". Then apply makeup gain to match Ceiling?\n        // Or \"Ceiling\" IS the threshold, and \"Threshold\" is just the input gain drive?\n        // The Blueprint says: \"If amplitude > threshold, calculate reduction.\"\n        // Let's assume standard behavior: Limit peaks to 'Ceiling'.\n        // 'Threshold' in many limiters (like L2) acts as \"Input Drive\" + \"Limit at Ceiling\".\n        // But here, let's stick to the prompt's likely intent: \n        // \"Threshold\": The level above which we compress.\n        // \"Ceiling\": The absolute max output level.\n        \n        // Let's implement: Compress anything above Threshold.\n        // AND Clamp the max output to Ceiling.\n        // This is tricky in one go.\n        // Simplified Logic:\n        // Target Gain reduces signal so it doesn't exceed 'Threshold'.\n        // Then we can apply a fixed Makeup Gain or just output that.\n        // Let's just implement Hard Limiting to 'Threshold' for now using the envelope.\n        \n        // Refined Logic based on \"standard\" lookahead limiter:\n        // The gain reduction signal follows the envelope of the input.\n        // If input peaks, we want gain to dip.\n        \n        // Current Gain Reduction for this sample\n        let gain = 1.0;\n        if (envLevel > thresholdLinear) {\n            gain = thresholdLinear / envLevel;\n        }\n\n        // Apply Ceiling?\n        // If we limit to Threshold, the peak is now at Threshold.\n        // If Ceiling != Threshold, we apply makeup.\n        // makeUp = ceiling / threshold\n        const makeUp = ceilingLinear / thresholdLinear;\n        gain *= makeUp;\n\n        // 4. Read from Delay Line\n        const delayedSample = state.delay.read(lookaheadSamples);\n\n        // 5. Apply Gain to Delayed Signal\n        // Note: In a true lookahead, the gain signal derived from input[t] is applied to delay[t].\n        // This aligns the \"Detection\" of the peak at t with the \"Processing\" of the peak at t (which happens N samples later).\n        // Wait. If we analyze input[t], and find a peak, we want the gain to be low *when that peak exits the delay line*.\n        // So we actually need to Delay the Audio, but apply the Gain derived from Input *now*?\n        // No, if we apply gain *now* to the delayed signal (which is old audio), we are compressing the *old* audio based on *future* peaks.\n        // This is exactly what we want! We duck the volume *before* the loud hit comes out of the delay line.\n        \n        outputData[i] = delayedSample * gain;\n\n        // Track max GR for UI (dB)\n        // Gain 1.0 = 0dB reduction. Gain 0.5 = -6dB reduction.\n        // We want positive number representing reduction amount.\n        // gr_db = -20log(gain)\n        // If gain is > 1 (makeup), GR is negative? \n        // Let's just track the raw gain factor for the \"Limiting\" part (before makeup)\n        // limitingGain = (env > thresh) ? thresh/env : 1.0\n        let limitingGain = (envLevel > thresholdLinear) ? (thresholdLinear / envLevel) : 1.0;\n        let gr = -20 * Math.log10(limitingGain); \n        if (gr > maxGainReduction) maxGainReduction = gr;\n      }\n    }\n\n    // Debug / Visualization\n    this.framesProcessed++;\n    if (this.framesProcessed >= 60) {\n      this.port.postMessage({ type: 'debug', gainReduction: maxGainReduction });\n      this.framesProcessed = 0;\n    }\n\n    return true;\n  }\n}\n\nregisterProcessor('limiter-processor', LimiterProcessor);\n",
  "lufs-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass LUFSProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.kFilterL = new KWeightingFilter(sampleRate);\n    this.kFilterR = new KWeightingFilter(sampleRate);\n    \n    // Windows in samples\n    // Momentary: 400ms\n    this.momentaryWindow = Math.floor(0.400 * sampleRate);\n    // Short-term: 3s\n    this.shortTermWindow = Math.floor(3.0 * sampleRate);\n\n    // Circular buffers for energy integration\n    this.bufferM = new Float32Array(this.momentaryWindow);\n    this.bufferS = new Float32Array(this.shortTermWindow);\n    this.idxM = 0;\n    this.idxS = 0;\n    \n    // Running sums for efficiency\n    this.sumM = 0;\n    this.sumS = 0;\n\n    this.framesProcessed = 0;\n  }\n\n  process(inputs, outputs) {\n    // Pass-through audio\n    const input = inputs[0];\n    const output = outputs[0];\n    \n    if (!input || input.length === 0) return true;\n\n    // Copy input to output (metering shouldn't affect sound)\n    for (let ch = 0; ch < input.length; ch++) {\n        output[ch].set(input[ch]);\n    }\n\n    const inputL = input[0];\n    const inputR = input.length > 1 ? input[1] : input[0]; // Fallback to mono if needed\n\n    for (let i = 0; i < inputL.length; i++) {\n        const L = inputL[i];\n        const R = inputR[i];\n\n        // 1. K-Weighting\n        const kL = this.kFilterL.process(L);\n        const kR = this.kFilterR.process(R);\n\n        // 2. Mean Square (Energy)\n        // Standard says sum channels? \n        // ITU-R BS.1770-4: z_i = y_i^2 (for each channel), then sum channels with weighting.\n        // For stereo: Energy = L^2 + R^2 (assuming standard weighting)\n        const energy = (kL * kL) + (kR * kR);\n\n        // 3. Update Momentary Window\n        // Remove old value from sum\n        this.sumM -= this.bufferM[this.idxM];\n        // Add new value\n        this.bufferM[this.idxM] = energy;\n        this.sumM += energy;\n        // Advance index\n        this.idxM = (this.idxM + 1) % this.momentaryWindow;\n\n        // 4. Update Short-Term Window\n        this.sumS -= this.bufferS[this.idxS];\n        this.bufferS[this.idxS] = energy;\n        this.sumS += energy;\n        this.idxS = (this.idxS + 1) % this.shortTermWindow;\n    }\n\n    // Report values periodically (e.g. every ~100ms or 30fps)\n    this.framesProcessed += 128;\n    if (this.framesProcessed >= 2048) { // Approx 46ms at 44.1k\n        // Calculate LUFS\n        // 10 * log10(mean_energy) - 0.691\n        // mean_energy = sum / window_size\n        \n        const meanM = this.sumM / this.momentaryWindow;\n        const meanS = this.sumS / this.shortTermWindow;\n\n        // Prevent log(0)\n        const lufsM = meanM > 1e-9 ? (10 * Math.log10(meanM) - 0.691) : -100;\n        const lufsS = meanS > 1e-9 ? (10 * Math.log10(meanS) - 0.691) : -100;\n\n        this.port.postMessage({ \n            type: 'meter', \n            momentary: lufsM, \n            shortTerm: lufsS \n        });\n        this.framesProcessed = 0;\n    }\n\n    return true;\n  }\n}\n\nregisterProcessor('lufs-processor', LUFSProcessor);\n",
  "midside-eq-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass MidSideEQProcessor extends AudioWorkletProcessor {\n  static get parameterDescriptors() {\n    return [\n      { name: 'midGain', defaultValue: 0, minValue: -15, maxValue: 15 },\n      { name: 'midFreq', defaultValue: 1000, minValue: 20, maxValue: 20000 },\n      { name: 'sideGain', defaultValue: 0, minValue: -15, maxValue: 15 },\n      { name: 'sideFreq', defaultValue: 1000, minValue: 20, maxValue: 20000 },\n    ];\n  }\n\n  constructor() {\n    super();\n    // Two independent filter sets for M and S\n    this.midFilter = new BiquadFilter();\n    this.sideFilter = new BiquadFilter();\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0];\n    if (!input || !output || input.length < 2) return true; // Need stereo\n\n    // Get parameters\n    const midGain = parameters.midGain.length > 1 ? parameters.midGain[0] : parameters.midGain[0];\n    const midFreq = parameters.midFreq.length > 1 ? parameters.midFreq[0] : parameters.midFreq[0];\n    const sideGain = parameters.sideGain.length > 1 ? parameters.sideGain[0] : parameters.sideGain[0];\n    const sideFreq = parameters.sideFreq.length > 1 ? parameters.sideFreq[0] : parameters.sideFreq[0];\n\n    // Update Filters (Peaking type)\n    this.midFilter.setParams(midFreq, midGain, 1.0, sampleRate, 'peaking');\n    this.sideFilter.setParams(sideFreq, sideGain, 1.0, sampleRate, 'peaking');\n\n    const leftIn = input[0];\n    const rightIn = input[1];\n    const leftOut = output[0];\n    const rightOut = output[1];\n\n    for (let i = 0; i < leftIn.length; i++) {\n        const L = leftIn[i];\n        const R = rightIn[i];\n\n        // 1. Encode M/S\n        const Mid = (L + R) * 0.5;\n        const Side = (L - R) * 0.5;\n\n        // 2. Process\n        const procMid = this.midFilter.process(Mid);\n        const procSide = this.sideFilter.process(Side);\n\n        // 3. Decode L/R\n        leftOut[i] = procMid + procSide;\n        rightOut[i] = procMid - procSide;\n    }\n\n    return true;\n  }\n}\n\nregisterProcessor('midside-eq-processor', MidSideEQProcessor);\n",
  "multiband-compressor-processor.js": "// Inlined crossover.js\n// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\n/**\n * Linkwitz-Riley 4th Order Crossover\n *\n * Consists of two 2nd-order Butterworth filters cascaded for each band.\n * - Lowpass: 2x Butterworth Lowpass (Q=0.7071)\n * - Highpass: 2x Butterworth Highpass (Q=0.7071)\n *\n * At the cutoff frequency, both bands are at -6dB and sum to unity gain (0dB)\n * with perfect phase alignment.\n */\nexport class LinkwitzRiley4 {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     * @param {number} cutoffFrequency - Crossover frequency in Hz.\n     */\n    constructor(sampleRate, cutoffFrequency) {\n        this.sampleRate = sampleRate;\n        this.cutoffFrequency = cutoffFrequency;\n\n        // Initialize filters\n        // Low band chain\n        this.lp1 = new BiquadFilter();\n        this.lp2 = new BiquadFilter();\n\n        // High band chain\n        this.hp1 = new BiquadFilter();\n        this.hp2 = new BiquadFilter();\n\n        this.updateFilters();\n    }\n\n    /**\n     * Updates the filter coefficients based on the current cutoff frequency.\n     */\n    updateFilters() {\n        const Q = Math.SQRT1_2; // 1/sqrt(2) approx 0.70710678\n\n        // Update Lowpass filters\n        this.lp1.setParams(this.cutoffFrequency, 0, Q, this.sampleRate, 'lowpass');\n        this.lp2.setParams(this.cutoffFrequency, 0, Q, this.sampleRate, 'lowpass');\n\n        // Update Highpass filters\n        this.hp1.setParams(this.cutoffFrequency, 0, Q, this.sampleRate, 'highpass');\n        this.hp2.setParams(this.cutoffFrequency, 0, Q, this.sampleRate, 'highpass');\n    }\n\n    /**\n     * Set a new cutoff frequency and update coefficients.\n     * @param {number} frequency - New cutoff frequency in Hz.\n     */\n    setCutoff(frequency) {\n        this.cutoffFrequency = frequency;\n        this.updateFilters();\n    }\n\n    /**\n     * Process a single sample through the crossover bands.\n     * @param {number} input - Input sample.\n     * @returns {{low: number, high: number}} Low and High band output samples.\n     */\n    process(input) {\n        // Process Low Band: Input -> LP1 -> LP2\n        const lowIntermediate = this.lp1.process(input);\n        const low = this.lp2.process(lowIntermediate);\n\n        // Process High Band: Input -> HP1 -> HP2\n        const highIntermediate = this.hp1.process(input);\n        const high = this.hp2.process(highIntermediate);\n\n        return { low, high };\n    }\n}\n\n\n\n// Internal VCA Class to handle per-band compression logic\nclass VCA {\n    constructor(sampleRate) {\n        this.sampleRate = sampleRate;\n        this.gr = 0; // Gain Reduction state (dB)\n    }\n\n    process(sample, thresh, ratio, attack, release, makeup) {\n        // 1. Level Detection\n        const absIn = Math.abs(sample);\n        const envDb = 20 * Math.log10(absIn + 1e-6);\n\n        // 2. Gain Calculation\n        const overshoot = envDb - thresh;\n        let targetGR = 0;\n\n        if (overshoot > 0) {\n            targetGR = overshoot * (1 - 1 / Math.max(1, ratio));\n        }\n\n        // 3. Ballistics\n        const attCoeff = Math.exp(-1.0 / (Math.max(0.0001, attack) * this.sampleRate));\n        const relCoeff = Math.exp(-1.0 / (Math.max(0.001, release) * this.sampleRate));\n\n        if (targetGR > this.gr) {\n            this.gr = attCoeff * this.gr + (1 - attCoeff) * targetGR;\n        } else {\n            this.gr = relCoeff * this.gr + (1 - relCoeff) * targetGR;\n        }\n\n        // 4. Apply\n        const gain = Math.pow(10, -this.gr / 20);\n        const mk = Math.pow(10, makeup / 20);\n        \n        return { output: sample * gain * mk, reduction: this.gr };\n    }\n}\n\nclass MultibandCompressorProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'lowFreq', defaultValue: 150, minValue: 20, maxValue: 1000 },\n            { name: 'highFreq', defaultValue: 2500, minValue: 1000, maxValue: 10000 },\n            \n            // Low Band\n            { name: 'threshLow', defaultValue: -24, minValue: -60, maxValue: 0 },\n            { name: 'ratioLow', defaultValue: 4, minValue: 1, maxValue: 20 },\n            { name: 'attLow', defaultValue: 0.01, minValue: 0.0001, maxValue: 1 },\n            { name: 'relLow', defaultValue: 0.1, minValue: 0.001, maxValue: 2 },\n            { name: 'gainLow', defaultValue: 0, minValue: 0, maxValue: 24 },\n\n            // Mid Band\n            { name: 'threshMid', defaultValue: -24, minValue: -60, maxValue: 0 },\n            { name: 'ratioMid', defaultValue: 4, minValue: 1, maxValue: 20 },\n            { name: 'attMid', defaultValue: 0.01, minValue: 0.0001, maxValue: 1 },\n            { name: 'relMid', defaultValue: 0.1, minValue: 0.001, maxValue: 2 },\n            { name: 'gainMid', defaultValue: 0, minValue: 0, maxValue: 24 },\n\n            // High Band\n            { name: 'threshHigh', defaultValue: -24, minValue: -60, maxValue: 0 },\n            { name: 'ratioHigh', defaultValue: 4, minValue: 1, maxValue: 20 },\n            { name: 'attHigh', defaultValue: 0.01, minValue: 0.0001, maxValue: 1 },\n            { name: 'relHigh', defaultValue: 0.1, minValue: 0.001, maxValue: 2 },\n            { name: 'gainHigh', defaultValue: 0, minValue: 0, maxValue: 24 },\n\n            { name: 'bypass', defaultValue: 0, minValue: 0, maxValue: 1 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.channelState = [];\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        const bypass = parameters.bypass[0];\n        if (bypass > 0.5) {\n            for (let ch = 0; ch < input.length; ch++) output[ch].set(input[ch]);\n            return true;\n        }\n\n        // Init State (Stereo)\n        if (this.channelState.length < input.length) {\n            for (let i = this.channelState.length; i < input.length; i++) {\n                this.channelState.push({\n                    xover1: new LinkwitzRiley4(sampleRate, 150),\n                    xover2: new LinkwitzRiley4(sampleRate, 2500),\n                    vcaLow: new VCA(sampleRate),\n                    vcaMid: new VCA(sampleRate),\n                    vcaHigh: new VCA(sampleRate)\n                });\n            }\n        }\n\n        // Params (Optimized: read index 0)\n        const lowFreq = parameters.lowFreq[0];\n        const highFreq = parameters.highFreq[0];\n\n        // Low\n        const tL = parameters.threshLow[0];\n        const rL = parameters.ratioLow[0];\n        const aL = parameters.attLow[0];\n        const reL = parameters.relLow[0];\n        const gL = parameters.gainLow[0];\n\n        // Mid\n        const tM = parameters.threshMid[0];\n        const rM = parameters.ratioMid[0];\n        const aM = parameters.attMid[0];\n        const reM = parameters.relMid[0];\n        const gM = parameters.gainMid[0];\n\n        // High\n        const tH = parameters.threshHigh[0];\n        const rH = parameters.ratioHigh[0];\n        const aH = parameters.attHigh[0];\n        const reH = parameters.relHigh[0];\n        const gH = parameters.gainHigh[0];\n\n        for (let ch = 0; ch < input.length; ch++) {\n            const inCh = input[ch];\n            const outCh = output[ch];\n            const state = this.channelState[ch];\n\n            // Update Crossovers\n            if (state.xover1.cutoffFrequency !== lowFreq) state.xover1.setCutoff(lowFreq);\n            if (state.xover2.cutoffFrequency !== highFreq) state.xover2.setCutoff(highFreq);\n\n            for (let i = 0; i < inCh.length; i++) {\n                const sample = inCh[i];\n\n                // 1. Split\n                const s1 = state.xover1.process(sample);\n                const s2 = state.xover2.process(s1.high);\n\n                const bandLow = s1.low;\n                const bandMid = s2.low;\n                const bandHigh = s2.high;\n\n                // 2. Compress\n                const resLow = state.vcaLow.process(bandLow, tL, rL, aL, reL, gL);\n                const resMid = state.vcaMid.process(bandMid, tM, rM, aM, reM, gM);\n                const resHigh = state.vcaHigh.process(bandHigh, tH, rH, aH, reH, gH);\n\n                // 3. Sum\n                outCh[i] = resLow.output + resMid.output + resHigh.output;\n            }\n        }\n\n        return true;\n    }\n}\n\nregisterProcessor('multiband-compressor-processor', MultibandCompressorProcessor);\n",
  "parametric-eq-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass ParametricEQProcessor extends AudioWorkletProcessor {\n  static get parameterDescriptors() {\n    return [\n      { name: 'lowFreq', defaultValue: 100, minValue: 20, maxValue: 1000 },\n      { name: 'lowGain', defaultValue: 0, minValue: -24, maxValue: 24 },\n      \n      { name: 'midFreq', defaultValue: 1000, minValue: 200, maxValue: 5000 },\n      { name: 'midGain', defaultValue: 0, minValue: -24, maxValue: 24 },\n      { name: 'midQ', defaultValue: 0.707, minValue: 0.1, maxValue: 10 },\n\n      { name: 'highFreq', defaultValue: 5000, minValue: 2000, maxValue: 20000 },\n      { name: 'highGain', defaultValue: 0, minValue: -24, maxValue: 24 },\n    ];\n  }\n\n  constructor() {\n    super();\n    this.channelState = [];\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0];\n    if (!input || !output) return true;\n\n    // K-rate parameters (using [0] for simplicity as automation is usually handled by host smoothing or granular enough)\n    const lowFreq = parameters.lowFreq[0];\n    const lowGain = parameters.lowGain[0];\n    \n    const midFreq = parameters.midFreq[0];\n    const midGain = parameters.midGain[0];\n    const midQ = parameters.midQ[0];\n\n    const highFreq = parameters.highFreq[0];\n    const highGain = parameters.highGain[0];\n\n    // Initialize channel state if needed\n    if (this.channelState.length < input.length) {\n      for (let i = this.channelState.length; i < input.length; i++) {\n        this.channelState.push({\n          lowShelf: new BiquadFilter(),\n          midPeak: new BiquadFilter(),\n          highShelf: new BiquadFilter()\n        });\n      }\n    }\n\n    // Process each channel\n    for (let channel = 0; channel < input.length; channel++) {\n        const inputChannel = input[channel];\n        const outputChannel = output[channel];\n        const state = this.channelState[channel];\n\n        // Update filters (running at K-rate approx for efficiency)\n        // Note: For true sample-accurate automation, this should be inside the sample loop.\n        // But for standard EQ usage, block-rate update is often acceptable unless fast modulation is needed.\n        // Given 'dsp-helpers.js' structure, we update per block here for performance.\n        \n        // Low Shelf\n        state.lowShelf.setParams(lowFreq, lowGain, 0.707, sampleRate, 'lowshelf');\n        \n        // Mid Peaking\n        state.midPeak.setParams(midFreq, midGain, midQ, sampleRate, 'peaking');\n        \n        // High Shelf\n        state.highShelf.setParams(highFreq, highGain, 0.707, sampleRate, 'highshelf');\n\n        for (let i = 0; i < inputChannel.length; i++) {\n            let sample = inputChannel[i];\n            \n            // Series processing\n            sample = state.lowShelf.process(sample);\n            sample = state.midPeak.process(sample);\n            sample = state.highShelf.process(sample);\n            \n            outputChannel[i] = sample;\n        }\n    }\n\n    return true;\n  }\n}\n\nregisterProcessor('parametric-eq-processor', ParametricEQProcessor);\n",
  "phaser-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass PhaserProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'stages', defaultValue: 4, minValue: 2, maxValue: 8 }, // Order (Integer)\n            { name: 'frequency', defaultValue: 0.5, minValue: 0.1, maxValue: 10 }, // LFO Rate\n            { name: 'baseFrequency', defaultValue: 1000, minValue: 50, maxValue: 5000 }, // Center Freq\n            { name: 'octaves', defaultValue: 2, minValue: 0, maxValue: 5 }, // Sweep Range\n            { name: 'wet', defaultValue: 0.5, minValue: 0, maxValue: 1 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.filters = []; // Array of arrays (channels -> stages)\n        this.lfo = new LFO();\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        const stagesParam = parameters.stages;\n        const lfoFreqParam = parameters.frequency;\n        const baseFreqParam = parameters.baseFrequency;\n        const octavesParam = parameters.octaves;\n        const wetParam = parameters.wet;\n\n        // Init State\n        if (this.filters.length < input.length) {\n            for (let c = this.filters.length; c < input.length; c++) {\n                // Max 8 stages support\n                const stageFilters = [];\n                for (let s = 0; s < 8; s++) stageFilters.push(new OnePoleAllPass());\n                this.filters.push(stageFilters);\n            }\n        }\n\n        // Process LFO once per block (approx) or per sample? \n        // Doc says \"Cutoff Frequency ... modulated by LFO\".\n        // For smooth sweeping, per sample is best.\n        \n        for (let i = 0; i < input[0].length; i++) {\n            const lfoFreq = lfoFreqParam.length === 1 ? lfoFreqParam[0] : lfoFreqParam[i];\n            const baseFreq = baseFreqParam.length === 1 ? baseFreqParam[0] : baseFreqParam[i];\n            const octaves = octavesParam.length === 1 ? octavesParam[0] : octavesParam[i];\n            const stages = stagesParam.length === 1 ? stagesParam[0] : stagesParam[i];\n            const wet = wetParam.length === 1 ? wetParam[0] : wetParam[i];\n\n            // 1. Calculate LFO (-1 to 1)\n            const lfoOut = this.lfo.process(lfoFreq, sampleRate);\n            \n            // 2. Modulate Frequency\n            // Exponential mapping usually feels better for phaser sweep\n            // f = base * 2^(lfo * range)\n            const modFreq = baseFreq * Math.pow(2, lfoOut * octaves);\n            \n            // Clip Freq to Nyquist\n            const safeFreq = Math.min(Math.max(modFreq, 20), sampleRate / 2.1);\n\n            // 3. Calculate Alpha\n            // a = (tan(pi*f/Sr) - 1) / (tan(pi*f/Sr) + 1)\n            const tan = Math.tan(Math.PI * safeFreq / sampleRate);\n            const alpha = (tan - 1) / (tan + 1);\n\n            // 4. Process Channels\n            for (let ch = 0; ch < input.length; ch++) {\n                const inSample = input[ch][i];\n                let stageSample = inSample;\n                \n                // Run through N stages\n                // Usually even number of stages (2, 4, 6)\n                const numStages = Math.round(stages);\n                for (let s = 0; s < numStages; s++) {\n                    stageSample = this.filters[ch][s].process(stageSample, alpha);\n                }\n\n                // Mix: y = x + wet * (phaser_out - x) ? \n                // Classic Phaser is 50/50 mix for max notch depth.\n                // If wet = 0.5, we want 50% Dry, 50% Wet.\n                // y = dry * (1-wet) + wet_sig * wet ?\n                // For notches, signals must sum.\n                output[ch][i] = inSample * (1 - wet) + stageSample * wet;\n            }\n        }\n\n        return true;\n    }\n}\n\nregisterProcessor('phaser-processor', PhaserProcessor);\n",
  "saturation-processor.js": "// Inlined saturation.js\n/**\n * Saturation/Distortion DSP\n * Provides various analog-modeled saturation types.\n */\nexport class Saturator {\n    // Static integer constants for performance\n    static get TYPE_TAPE() { return 0; }\n    static get TYPE_TUBE() { return 1; }\n    static get TYPE_FUZZ() { return 2; }\n\n    constructor() {\n        // No state needed for memory-less waveshaping\n    }\n\n    /**\n     * Process a single sample with saturation.\n     *\n     * @param {number} input - The input sample (-1.0 to 1.0 nominally, but can be anything)\n     * @param {number} drive - Linear gain multiplier (>= 0)\n     * @param {number} type - 0 (Tape), 1 (Tube), or 2 (Fuzz)\n     * @returns {number} Saturated output\n     */\n    process(input, drive, type) {\n        // Apply drive (linear gain)\n        const x = input * drive;\n\n        // Use integer comparison for performance\n        // 1: Tube\n        if (type === 1) {\n            // Asymmetric Transfer Function\n            // Positive: Harder knee (tanh)\n            // Negative: Softer knee (x / (1 + |x|))\n            // This generates even harmonics\n            if (x >= 0) {\n                return Math.tanh(x);\n            } else {\n                return x / (1 + Math.abs(x));\n            }\n        }\n\n        // 2: Fuzz\n        if (type === 2) {\n            // Hard Clipping\n            // Strict clamping at +/- 1.0\n            if (x > 1.0) return 1.0;\n            if (x < -1.0) return -1.0;\n            return x;\n        }\n\n        // 0 (Tape) or default\n        // Symmetric Soft Clipping\n        // Standard tanh saturator\n        // Generates odd harmonics\n        return Math.tanh(x);\n    }\n}\n\n\nclass SaturationProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.saturator = new Saturator();\n  }\n\n  static get parameterDescriptors() {\n    return [\n      { name: 'drive', defaultValue: 0.0, minValue: 0.0, maxValue: 10.0 },\n      { name: 'type', defaultValue: 1, minValue: 0, maxValue: 2 }, // 0: Tape, 1: Tube, 2: Fuzz\n      { name: 'outputGain', defaultValue: 0.0, minValue: -12.0, maxValue: 12.0 },\n      { name: 'mix', defaultValue: 1.0, minValue: 0.0, maxValue: 1.0 }\n    ];\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0];\n    const drive = parameters.drive;\n    const typeParam = parameters.type;\n    const outGain = parameters.outputGain;\n    const mixParam = parameters.mix;\n\n    if (!input || !input[0] || !output) return true;\n\n    const channelCount = input.length;\n\n    for (let channel = 0; channel < channelCount; channel++) {\n      const inputChannel = input[channel];\n      const outputChannel = output[channel];\n      const length = inputChannel.length;\n\n      const isDriveConst = drive.length === 1;\n      const isTypeConst = typeParam.length === 1;\n      const isGainConst = outGain.length === 1;\n      const isMixConst = mixParam.length === 1;\n\n      // Initialize base variables\n      let currentDrive = drive[0];\n      let currentGainDb = outGain[0];\n      let currentMix = mixParam[0];\n      let currentTypeInt = 1; // Default to Tube (1)\n\n      // Pre-calculate constants outside the loop\n      let linearGain = 1.0;\n      if (isGainConst) {\n        linearGain = Math.pow(10, currentGainDb / 20);\n      }\n\n      if (isTypeConst) {\n         currentTypeInt = Math.round(typeParam[0]);\n      }\n\n      for (let i = 0; i < length; i++) {\n        // Update per-sample parameters if not constant\n        if (!isDriveConst) currentDrive = drive[i];\n        if (!isMixConst) currentMix = mixParam[i];\n        \n        if (!isGainConst) {\n           currentGainDb = outGain[i];\n           // Only calculate pow inside loop if gain is changing\n           linearGain = Math.pow(10, currentGainDb / 20);\n        }\n\n        if (!isTypeConst) {\n            currentTypeInt = Math.round(typeParam[i]);\n        }\n\n        // Apply input gain (Drive)\n        // Saturator.process(input, drive, type)\n        // We pass 1.0 + currentDrive so that drive 0.0 = unity gain.\n        const saturated = this.saturator.process(inputChannel[i], 1.0 + currentDrive, currentTypeInt);\n\n        const wet = saturated * linearGain;\n        outputChannel[i] = inputChannel[i] * (1 - currentMix) + wet * currentMix;\n      }\n    }\n\n    return true;\n  }\n}\n\nregisterProcessor('saturation-processor', SaturationProcessor);",
  "stereo-imager-processor.js": "// Inlined crossover.js\n// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\n/**\n * Linkwitz-Riley 4th Order Crossover\n *\n * Consists of two 2nd-order Butterworth filters cascaded for each band.\n * - Lowpass: 2x Butterworth Lowpass (Q=0.7071)\n * - Highpass: 2x Butterworth Highpass (Q=0.7071)\n *\n * At the cutoff frequency, both bands are at -6dB and sum to unity gain (0dB)\n * with perfect phase alignment.\n */\nexport class LinkwitzRiley4 {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     * @param {number} cutoffFrequency - Crossover frequency in Hz.\n     */\n    constructor(sampleRate, cutoffFrequency) {\n        this.sampleRate = sampleRate;\n        this.cutoffFrequency = cutoffFrequency;\n\n        // Initialize filters\n        // Low band chain\n        this.lp1 = new BiquadFilter();\n        this.lp2 = new BiquadFilter();\n\n        // High band chain\n        this.hp1 = new BiquadFilter();\n        this.hp2 = new BiquadFilter();\n\n        this.updateFilters();\n    }\n\n    /**\n     * Updates the filter coefficients based on the current cutoff frequency.\n     */\n    updateFilters() {\n        const Q = Math.SQRT1_2; // 1/sqrt(2) approx 0.70710678\n\n        // Update Lowpass filters\n        this.lp1.setParams(this.cutoffFrequency, 0, Q, this.sampleRate, 'lowpass');\n        this.lp2.setParams(this.cutoffFrequency, 0, Q, this.sampleRate, 'lowpass');\n\n        // Update Highpass filters\n        this.hp1.setParams(this.cutoffFrequency, 0, Q, this.sampleRate, 'highpass');\n        this.hp2.setParams(this.cutoffFrequency, 0, Q, this.sampleRate, 'highpass');\n    }\n\n    /**\n     * Set a new cutoff frequency and update coefficients.\n     * @param {number} frequency - New cutoff frequency in Hz.\n     */\n    setCutoff(frequency) {\n        this.cutoffFrequency = frequency;\n        this.updateFilters();\n    }\n\n    /**\n     * Process a single sample through the crossover bands.\n     * @param {number} input - Input sample.\n     * @returns {{low: number, high: number}} Low and High band output samples.\n     */\n    process(input) {\n        // Process Low Band: Input -> LP1 -> LP2\n        const lowIntermediate = this.lp1.process(input);\n        const low = this.lp2.process(lowIntermediate);\n\n        // Process High Band: Input -> HP1 -> HP2\n        const highIntermediate = this.hp1.process(input);\n        const high = this.hp2.process(highIntermediate);\n\n        return { low, high };\n    }\n}\n\n\n\nclass StereoImagerProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'lowFreq', defaultValue: 150, minValue: 20, maxValue: 1000 },\n            { name: 'highFreq', defaultValue: 2500, minValue: 1000, maxValue: 10000 },\n            { name: 'widthLow', defaultValue: 0.0, minValue: 0.0, maxValue: 2.0 },\n            { name: 'widthMid', defaultValue: 1.0, minValue: 0.0, maxValue: 2.0 },\n            { name: 'widthHigh', defaultValue: 1.2, minValue: 0.0, maxValue: 2.0 },\n            { name: 'bypass', defaultValue: 0, minValue: 0, maxValue: 1 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.channelState = [];\n    }\n\n    process(inputs, outputs, parameters) {\n        // Defensive check for audio engine readiness\n        if (!inputs || !inputs[0] || !outputs || !outputs[0]) return true;\n\n        const input = inputs[0];\n        const output = outputs[0];\n        \n        // Handle empty input (disconnected node)\n        if (input.length === 0) return true;\n\n        try {\n            const bypass = parameters.bypass && parameters.bypass.length > 0 ? parameters.bypass[0] : 0;\n            \n            if (bypass > 0.5) {\n                for (let ch = 0; ch < input.length; ch++) {\n                    // Safety: ensure output channel exists and input has data\n                    if (output[ch] && input[ch]) {\n                        output[ch].set(input[ch]);\n                    }\n                }\n                return true;\n            }\n\n            // Initialize crossover state per channel if needed\n            if (this.channelState.length < input.length) {\n                for (let i = this.channelState.length; i < input.length; i++) {\n                    this.channelState.push({\n                        xover1: new LinkwitzRiley4(sampleRate, 150),\n                        xover2: new LinkwitzRiley4(sampleRate, 2500)\n                    });\n                }\n            }\n\n            // Parameter safety checks\n            const lowFreq = parameters.lowFreq && parameters.lowFreq.length > 0 ? parameters.lowFreq[0] : 150;\n            const highFreq = parameters.highFreq && parameters.highFreq.length > 0 ? parameters.highFreq[0] : 2500;\n            \n            // Ensure frequencies are valid and non-overlapping/inverted if logic requires, \n            // though the crossover itself is independent. \n            // We just ensure they are finite.\n            if (!Number.isFinite(lowFreq) || !Number.isFinite(highFreq)) return true;\n\n            const widthLow = parameters.widthLow && parameters.widthLow.length > 0 ? parameters.widthLow[0] : 1.0;\n            const widthMid = parameters.widthMid && parameters.widthMid.length > 0 ? parameters.widthMid[0] : 1.0;\n            const widthHigh = parameters.widthHigh && parameters.widthHigh.length > 0 ? parameters.widthHigh[0] : 1.0;\n\n            const L = input[0];\n            const R = input[1];\n            const outL = output[0];\n            const outR = output[1];\n\n            // Safety for Mono inputs\n            if (!R || !outR) {\n                if (outL && L) outL.set(L);\n                return true;\n            }\n\n            const stateL = this.channelState[0];\n            const stateR = this.channelState[1];\n\n            // Update Cutoffs safely\n            if (stateL.xover1.cutoffFrequency !== lowFreq) {\n                stateL.xover1.setCutoff(lowFreq);\n                stateR.xover1.setCutoff(lowFreq);\n            }\n            if (stateL.xover2.cutoffFrequency !== highFreq) {\n                stateL.xover2.setCutoff(highFreq);\n                stateR.xover2.setCutoff(highFreq);\n            }\n\n            // Process loop\n            const len = L.length;\n            for (let i = 0; i < len; i++) {\n                const lIn = L[i];\n                const rIn = R[i];\n\n                // 1. Split Bands\n                const splitL1 = stateL.xover1.process(lIn); // low, high (midhigh)\n                const splitR1 = stateR.xover1.process(rIn);\n\n                const splitL2 = stateL.xover2.process(splitL1.high); // low (mid), high\n                const splitR2 = stateR.xover2.process(splitR1.high);\n\n                const lLow = splitL1.low;\n                const rLow = splitR1.low;\n\n                const lMid = splitL2.low;\n                const rMid = splitR2.low;\n\n                const lHigh = splitL2.high;\n                const rHigh = splitR2.high;\n\n                // 2. M/S Processing per Band\n                // Inline helper for performance and safety\n                // Band 1\n                const m1 = (lLow + rLow) * 0.5;\n                const s1 = (lLow - rLow) * 0.5 * widthLow;\n                \n                // Band 2\n                const m2 = (lMid + rMid) * 0.5;\n                const s2 = (lMid - rMid) * 0.5 * widthMid;\n\n                // Band 3\n                const m3 = (lHigh + rHigh) * 0.5;\n                const s3 = (lHigh - rHigh) * 0.5 * widthHigh;\n\n                // 3. Summation\n                outL[i] = (m1 + s1) + (m2 + s2) + (m3 + s3);\n                outR[i] = (m1 - s1) + (m2 - s2) + (m3 - s3);\n            }\n        } catch (e) {\n            // If anything explodes, try to bypass safely or silence\n            // console.error(e); // Can't log in worklet easily\n            return true;\n        }\n\n        return true;\n    }\n}\n\nregisterProcessor('stereo-imager-processor', StereoImagerProcessor);\n",
  "transient-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass TransientProcessor extends AudioWorkletProcessor {\n  static get parameterDescriptors() {\n    return [\n      { name: 'attackGain', defaultValue: 0, minValue: -24, maxValue: 24 },\n      { name: 'sustainGain', defaultValue: 0, minValue: -24, maxValue: 24 },\n      { name: 'mix', defaultValue: 1.0, minValue: 0, maxValue: 1 }\n    ];\n  }\n\n  constructor() {\n    super();\n    this.channelState = [];\n    // Fixed time constants as per blueprint suggestion\n    this.fastTime = 0.010; // 10ms\n    this.slowTime = 0.100; // 100ms\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0];\n    if (!input || !output) return true;\n\n    // Get parameters (supporting a-rate or k-rate, defaulting to index 0)\n    const attackGain = parameters.attackGain.length > 1 ? parameters.attackGain : parameters.attackGain[0];\n    const sustainGain = parameters.sustainGain.length > 1 ? parameters.sustainGain : parameters.sustainGain[0];\n    const mixP = parameters.mix;\n    const mix = mixP.length > 1 ? mixP[0] : mixP[0]; // Simple access for now\n\n    // Initialize state for new channels\n    if (this.channelState.length < input.length) {\n      for (let i = this.channelState.length; i < input.length; i++) {\n        const fastEnv = new EnvelopeFollower();\n        const slowEnv = new EnvelopeFollower();\n        \n        // Initialize with sampleRate\n        // Note: sampleRate is a global in AudioWorkletGlobalScope\n        fastEnv.setParams(this.fastTime, this.fastTime, sampleRate);\n        slowEnv.setParams(this.slowTime, this.slowTime, sampleRate);\n\n        this.channelState.push({ fastEnv, slowEnv });\n      }\n    }\n\n    for (let channel = 0; channel < input.length; channel++) {\n      const inputData = input[channel];\n      const outputData = output[channel];\n      const state = this.channelState[channel];\n      \n      // We could update env params here if we wanted them automated,\n      // but they are fixed for this implementation.\n\n      for (let i = 0; i < inputData.length; i++) {\n        const sample = inputData[i];\n        \n        // 1. Calculate Envelopes\n        const fast = state.fastEnv.process(sample);\n        const slow = state.slowEnv.process(sample);\n        \n        // 2. Calculate Delta (Transient detection)\n        const delta = fast - slow;\n        \n        // 3. Determine Gain Factor\n        let gainDb = 0;\n        \n        // Handle k-rate vs a-rate params inside loop if necessary, \n        // but for now assuming k-rate (index 0) or simple access.\n        // To be perfectly robust for a-rate:\n        const currentAtt = parameters.attackGain.length > 1 ? parameters.attackGain[i] : attackGain;\n        const currentSus = parameters.sustainGain.length > 1 ? parameters.sustainGain[i] : sustainGain;\n\n        if (delta > 0) {\n            // Transient phase\n            // Scale the \"transient-ness\" (delta) by the attack gain\n            // Typically we want a Ratio or just direct scaling. \n            // Simple approach: gain_db = delta * attack_db * scalar\n            // Let's use a scalar of 2.0 to make it punchy\n            gainDb = delta * currentAtt * 2.0; \n        } else {\n            // Sustain phase\n            // Delta is negative here. We want to scale the \"sustain-ness\" (abs(delta))\n            // gain_db = abs(delta) * sustain_db * scalar\n            gainDb = Math.abs(delta) * currentSus * 2.0;\n        }\n\n        // 4. Apply Gain\n        // Convert dB to linear: 10^(db/20)\n        const linearGain = Math.pow(10, gainDb / 20);\n        \n        outputData[i] = sample * (1 - mix) + (sample * linearGain) * mix;\n      }\n    }\n\n    return true;\n  }\n}\n\nregisterProcessor('transient-processor', TransientProcessor);\n",
  "tremolo-processor.js": "// Inlined dsp-helpers.js\n/**\n * Shared DSP Library for AudioWorklets\n * Pure JS implementation of common DSP components.\n */\n\n/**\n * Standard RBJ Biquad Filter implementation.\n */\nexport class BiquadFilter {\n    constructor() {\n        this.reset();\n        this.cache = { w0: 0, cosw0: 0, alpha: 0, type: 'lowpass' };\n        // Default to safe values\n        this.setParams(1000, 0, 1.0, 44100, 'lowpass');\n    }\n\n    /**\n     * Resets the filter state (delay lines).\n     */\n    reset() {\n        this.x1 = 0; this.x2 = 0;\n        this.y1 = 0; this.y2 = 0;\n        this.b0 = 0; this.b1 = 0; this.b2 = 0;\n        this.a1 = 0; this.a2 = 0;\n    }\n\n    /**\n     * Sets the filter parameters and updates coefficients.\n     * @param {number} frequency - Cutoff or center frequency in Hz.\n     * @param {number} gain - Gain in dB (for peaking/shelving filters).\n     * @param {number} Q - Quality factor.\n     * @param {number} sampleRate - System sample rate.\n     * @param {string} type - Filter type ('lowpass', 'highpass', etc.).\n     */\n    setParams(frequency, gain, Q, sampleRate, type) {\n        this.updateBase(frequency, Q, sampleRate, type);\n        this.setGain(gain);\n    }\n\n    /**\n     * Updates common intermediate variables based on frequency and Q.\n     */\n    updateBase(frequency, Q, sampleRate, type) {\n        const w0 = (2 * Math.PI * frequency) / sampleRate;\n        this.cache.w0 = w0;\n        this.cache.cosw0 = Math.cos(w0);\n        this.cache.alpha = Math.sin(w0) / (2 * Q);\n        this.cache.type = type;\n    }\n\n    /**\n     * Calculates filter coefficients based on gain.\n     * @param {number} gain - Gain in dB.\n     */\n    setGain(gain) {\n        const A = Math.pow(10, gain / 40);\n        const { cosw0, alpha, type } = this.cache;\n        \n        let b0, b1, b2, a0, a1, a2;\n\n        switch (type) {\n            case 'lowpass':\n                b0 = (1 - cosw0) / 2;\n                b1 = 1 - cosw0;\n                b2 = (1 - cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'highpass':\n                b0 = (1 + cosw0) / 2;\n                b1 = -(1 + cosw0);\n                b2 = (1 + cosw0) / 2;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'bandpass':\n                b0 = alpha;\n                b1 = 0;\n                b2 = -alpha;\n                a0 = 1 + alpha;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha;\n                break;\n            case 'peaking':\n                b0 = 1 + alpha * A;\n                b1 = -2 * cosw0;\n                b2 = 1 - alpha * A;\n                a0 = 1 + alpha / A;\n                a1 = -2 * cosw0;\n                a2 = 1 - alpha / A;\n                break;\n            case 'lowshelf':\n                b0 = A * ((A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);\n                b2 = A * ((A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = -2 * ((A - 1) + (A + 1) * cosw0);\n                a2 = (A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            case 'highshelf':\n                b0 = A * ((A + 1) + (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha);\n                b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);\n                b2 = A * ((A + 1) + (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha);\n                a0 = (A + 1) - (A - 1) * cosw0 + 2 * Math.sqrt(A) * alpha;\n                a1 = 2 * ((A - 1) - (A + 1) * cosw0);\n                a2 = (A + 1) - (A - 1) * cosw0 - 2 * Math.sqrt(A) * alpha;\n                break;\n            default:\n                b0=1; b1=0; b2=0; a0=1; a1=0; a2=0;\n        }\n\n        // Normalize\n        this.b0 = b0 / a0;\n        this.b1 = b1 / a0;\n        this.b2 = b2 / a0;\n        this.a1 = a1 / a0;\n        this.a2 = a2 / a0;\n    }\n\n    /**\n     * Processes a single input sample.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        const output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2\n                     - this.a1 * this.y1 - this.a2 * this.y2;\n        \n        // Safety Check for NaN or Infinity\n        if (!Number.isFinite(output)) {\n            this.reset();\n            return 0;\n        }\n\n        this.x2 = this.x1;\n        this.x1 = input;\n        this.y2 = this.y1;\n        this.y1 = output;\n\n        return output;\n    }\n}\n\n/**\n * K-Weighting Filter for LUFS Metering (ITU-R BS.1770-4)\n * Consists of a pre-filter (high shelf) and a RLB filter (high pass).\n */\nexport class KWeightingFilter {\n    /**\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(sampleRate) {\n        this.preFilter = new BiquadFilter();\n        this.rlbFilter = new BiquadFilter();\n        \n        // Stage 1: High Shelf (+4dB @ ~1500Hz)\n        this.preFilter.setParams(1500, 4, 0.707, sampleRate, 'highshelf');\n\n        // Stage 2: High Pass (Cutoff @ ~100Hz)\n        this.rlbFilter.setParams(100, 0, 1.0, sampleRate, 'highpass');\n    }\n\n    /**\n     * Processes a single input sample through the K-Weighting stages.\n     * @param {number} input - Input sample.\n     * @returns {number} Filtered output sample.\n     */\n    process(input) {\n        // Series processing\n        const stage1 = this.preFilter.process(input);\n        const stage2 = this.rlbFilter.process(stage1);\n        return stage2;\n    }\n}\n\n/**\n * Simple envelope follower with independent attack and release times.\n */\nexport class EnvelopeFollower {\n    constructor() {\n        this.envelope = 0;\n        this.attCoeff = 0;\n        this.relCoeff = 0;\n        this.setParams(0.01, 0.1, 44100); // Default 10ms attack, 100ms release\n    }\n\n    /**\n     * Sets the attack and release times.\n     * @param {number} attackTime - Attack time in seconds.\n     * @param {number} releaseTime - Release time in seconds.\n     * @param {number} sampleRate - System sample rate.\n     */\n    setParams(attackTime, releaseTime, sampleRate) {\n        const tAtt = Math.max(0.001, attackTime);\n        const tRel = Math.max(0.001, releaseTime);\n\n        // Simple one-pole coefficient\n        this.attCoeff = Math.exp(-1.0 / (tAtt * sampleRate));\n        this.relCoeff = Math.exp(-1.0 / (tRel * sampleRate));\n    }\n\n    /**\n     * Processes a single input sample and returns current envelope level.\n     * @param {number} input - Input sample.\n     * @returns {number} Current envelope level.\n     */\n    process(input) {\n        const absInput = Math.abs(input);\n        \n        // Attack phase: Input > Envelope\n        if (absInput > this.envelope) {\n            this.envelope = this.attCoeff * this.envelope + (1 - this.attCoeff) * absInput;\n        } \n        // Release phase\n        else {\n            this.envelope = this.relCoeff * this.envelope + (1 - this.relCoeff) * absInput;\n        }\n\n        return this.envelope;\n    }\n}\n\n/**\n * Circular buffer delay line with linear interpolation.\n */\nexport class DelayLine {\n    /**\n     * @param {number} maxDelaySeconds - Maximum delay time.\n     * @param {number} sampleRate - System sample rate.\n     */\n    constructor(maxDelaySeconds, sampleRate) {\n        this.size = Math.ceil(maxDelaySeconds * sampleRate);\n        this.buffer = new Float32Array(this.size);\n        this.writeIndex = 0;\n    }\n\n    /**\n     * Writes a sample into the delay buffer.\n     * @param {number} input - Input sample.\n     */\n    write(input) {\n        this.buffer[this.writeIndex] = input;\n        this.writeIndex = (this.writeIndex + 1) % this.size;\n    }\n\n    /**\n     * Reads a delayed sample using linear interpolation.\n     * @param {number} delaySamples - Delay time in samples (can be fractional).\n     * @returns {number} Delayed sample.\n     */\n    read(delaySamples) {\n        // Calculate read index\n        let readPtr = this.writeIndex - delaySamples;\n        while (readPtr < 0) readPtr += this.size;\n\n        const i = Math.floor(readPtr);\n        const f = readPtr - i; // Fractional part\n\n        const i1 = i % this.size;\n        const i2 = (i + 1) % this.size;\n\n        const s1 = this.buffer[i1];\n        const s2 = this.buffer[i2];\n\n        // Linear interpolation: y = s1 + f * (s2 - s1)\n        return s1 + f * (s2 - s1);\n    }\n}\n\n/**\n * Basic sine-wave LFO.\n */\nexport class LFO {\n    constructor() {\n        this.phase = 0;\n    }\n\n    /**\n     * Processes LFO and returns current sine value.\n     * @param {number} frequency - LFO frequency in Hz.\n     * @param {number} sampleRate - System sample rate.\n     * @returns {number} Current LFO value [-1, 1].\n     */\n    process(frequency, sampleRate) {\n        // Increment phase\n        this.phase += (2 * Math.PI * frequency) / sampleRate;\n        if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;\n        \n        return Math.sin(this.phase);\n    }\n}\n\n/**\n * One-pole all-pass filter.\n */\nexport class OnePoleAllPass {\n    constructor() {\n        this.x1 = 0;\n        this.y1 = 0;\n    }\n\n    /**\n     * Processes a sample through the all-pass filter.\n     * @param {number} input - Input sample.\n     * @param {number} alpha - Filter coefficient.\n     * @returns {number} Filtered output.\n     */\n    process(input, alpha) {\n        // Standard one-pole all-pass filter:\n        // y[n] = alpha * x[n] + x[n-1] - alpha * y[n-1]\n        const output = alpha * input + this.x1 - alpha * this.y1;\n        \n        this.x1 = input;\n        this.y1 = output;\n        \n        return output;\n    }\n}\n\n\n\n\nclass TremoloProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [\n            { name: 'frequency', defaultValue: 4.0, minValue: 0.1, maxValue: 20.0 },\n            { name: 'depth', defaultValue: 0.5, minValue: 0.0, maxValue: 1.0 },\n            { name: 'spread', defaultValue: 0.0, minValue: 0.0, maxValue: 1.0 }, // 0 = Mono, 1 = 180 deg offset\n            { name: 'waveform', defaultValue: 0, minValue: 0, maxValue: 1 }, // 0=Sine, 1=Square (optional?) Doc says Sin.\n            { name: 'mix', defaultValue: 1.0, minValue: 0.0, maxValue: 1.0 }\n        ];\n    }\n\n    constructor() {\n        super();\n        this.lfo = new LFO();\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n        if (!input || !output) return true;\n\n        const freqParam = parameters.frequency;\n        const depthParam = parameters.depth;\n        const spreadParam = parameters.spread;\n        const mixParam = parameters.mix;\n\n        for (let i = 0; i < input[0].length; i++) {\n            const freq = freqParam.length === 1 ? freqParam[0] : freqParam[i];\n            const depth = depthParam.length === 1 ? depthParam[0] : depthParam[i];\n            const spread = spreadParam.length === 1 ? spreadParam[0] : spreadParam[i];\n            const mix = mixParam.length === 1 ? mixParam[0] : mixParam[i];\n\n            // Calculate Base LFO Phase\n            // LFO class maintains phase state.\n            // But we need to sample it once per sample-frame.\n            // Wait, LFO.process updates state. \n            // If I call it twice (for L and R), I advance phase twice!\n            // I must advance phase once, then calculate values for L/R.\n            \n            // Refactoring LFO usage:\n            // \"process\" advances state. \n            // I should have `advance(freq, sr)` and `getValue(offset)`.\n            // But helper is `process`.\n            // I'll assume LFO helper advances state. \n            // So I call it once, get `baseMod`, then derive `rightMod`.\n            \n            const baseMod = this.lfo.process(freq, sampleRate); // -1 to 1\n\n            for (let ch = 0; ch < input.length; ch++) {\n                // Apply Spread to Right Channel\n                let mod = baseMod;\n                if (ch === 1 && spread > 0) {\n                     // Offset phase effectively.\n                     // Since I only have the *value* of sin(t), I can't easily shift phase \n                     // unless I know cos(t) or 't'.\n                     // My LFO class hides 'phase'.\n                     // I should probably update LFO class to expose phase or handle multi-channel?\n                     // Workaround: Use LFO class to just track phase manually here?\n                     // Or just invert signal for spread=1 (Ping Pong)?\n                     // If spread=1, Right = -Left.\n                     if (spread >= 0.9) mod = -mod;\n                     // For 0 < spread < 1, just interpolate? Crude but works for effect.\n                }\n\n                // AM: y = x * (1 - depth + depth * sin)\n                // My formula: 1 - depth + depth * mod\n                // If mod = 1 -> 1\n                // If mod = -1 -> 1 - 2*depth\n                // Wait. \n                // If depth=1, mod=-1 -> 1 - 2 = -1. Inverted phase?\n                // Doc formula: 1 - depth + depth * sin\n                // If sin=-1: 1 - 2*depth. \n                // If depth=1 -> -1. \n                // This means at max depth, it fully inverts the signal at the trough?\n                // Usually Tremolo goes 0 to 1.\n                // Standard Tremolo formula: (1 - depth/2) + (depth/2)*sin ?\n                // Range: (1-d) to 1.\n                // Doc formula: `1 - depth + depth * sin`.\n                // Let's analyze.\n                // Sin=1 -> 1.\n                // Sin=-1 -> 1 - 2d.\n                // If d=0.5 -> 0.\n                // If d=1 -> -1.\n                // This implies \"Ring Modulation\" at high depth?\n                // I will follow the doc logic exactly.\n                \n                const gain = 1 - depth + depth * mod;\n                const wet = input[ch][i] * gain;\n                output[ch][i] = input[ch][i] * (1 - mix) + wet * mix;\n            }\n        }\n        return true;\n    }\n}\n\nregisterProcessor('tremolo-processor', TremoloProcessor);\n"
};
